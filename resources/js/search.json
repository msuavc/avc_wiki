[[{"l":"Welcome","p":["Welcome to the AVC Wiki! This aims to serve as a single source of truth for all AVC software, hardware, and other content."]},{"l":"New Members","p":["If you're new to the club and our software, you'll probably want to start with the basics! AVC's software stack is composed of: Robot Operating System (ROS) Python C++ Git","Since we have our own configuration for everything, we have written guides for your convenience. You'll probably want to start with the basics: ROS Basics Git Basics","After reading the basics sections, you can follow some tutorials that will give you hands on experience. From there, talk to your team leads or project leads to get started with development."]},{"l":"Developing Members","p":["For developers, the workflow section is there to guide you as you develop ROS software for the vehicle: Setting Up Branching and Merging Creating ROS Packages Creating ROS Nodes with Python","Creating ROS Nodes with C++ is coming soon."]}],[{"l":"ROS Basics","p":["For the vehicle to run as we need it to, it needs to have a backend program that is able to coordinate the flow of data between the sensors and the software that converts that sensor data into controls, detections, and other more relevant data for the vehicle to run autonomously. ROS is the solution that the team, and many others in the robotics industry, uses in order to do this coordination.","This page provides a general high-level overview of basic components in ROS, as well as the command-line tools that allow for inspection of these components."]},{"i":"what-is-ros","l":"What is ROS?","p":["ROS is middleware used to lighten the development load of robotics applications. Before software like ROS, developing any robotics platform required many man hours of development on features needed to just get the system running. If you were developing a system as complex as ours from scratch, you would need to develop every component in the system, from data management to testing. The project itself may even stall before the interesting research happens!","With ROS, most of the backend work is taken care of by the software itself. ROS is also a modular framework, meaning that you can swap different components as you see fit, only having to worry about inputs and outputs with each software component and not about how to handle all the low-level dataflow and implementation details."]},{"i":"relevant-links","l":"Relevant Links:","p":["More comprehensive introductions to ROS can be found here:","What Is ROS?","Introduction to ROS","Additionally, if at any time you cannot find the answers you are looking for here, the ROS wiki is a great resource that will fill you in on the finer details without having you frantically google everything:","http://wiki.ros.org/ROS","Finally, each section will have links directing you towards comprehensive documentation provided by the ROS development team itself. Most of the information is explained in much more detail there, and many of the command-line instructions found below are a simple subset of the functionality they actually offer. It is encouraged that you read this links during/after your time reading this document."]},{"l":"Packages","p":["ROS Reference for Packages","Packages are at the core of ROS’ system. Packages contain all nodes, services, message types, and more that are present in the system. At a basic level, however, they are just directories containing source code and configuration files allowing for separation of codebases based on their purpose. This is ROS’ way of handling part of directory management for you."]},{"l":"Directories and Files","p":["A ROS package, at a basic level, is just a parent directory. This parent can contain anything, but the files subdirectories that are relevant to the package are explained below:"]},{"i":"src","l":"./src/","p":["This is where all of your python source code will be stored, and in that source code will be nodes, services, and other coded functionality on the vehicle."]},{"i":"srcpackage_name","l":"./src/package_name","p":["This is where all of your C++ source code will be stored, and in that source code will be nodes, services, and other coded functionality on the vehicle."]},{"i":"cmakeliststxt","l":"./CMakeLists.txt","p":["This is the cmake build file for the package, and it is required for building and running the package. Stored in here are all the cmake directives and other information needed to actually build the package for use. I will not go into the contents of this file here, as it is quite complex and is created when building a package ( See Development in ROS). For more information about the contents of this file, you can also refer to ROS’ CMakeLists documentation."]},{"i":"packagexml","l":"./package.xml","p":["This file is the package manifest, and it is another file required for building and running from a package. Information here is similar to CMakeLists.txt, and similarly, I will not go into the file contents due to complexity. For information, you can also refer to ROS’ package.xml documentation."]},{"i":"msg","l":"./msg/","p":["This folder will contain all custom message types defined in the package. Most packages will not need this, as there are both ROS provided and custom defined messages already defined in the system that should suffice. If not, however, this folder is here.","More about ROS messages below."]},{"i":"srv","l":"./srv/","p":["This folder will contain all custom defined service types. If you are creating a service, you will define the data the service will request and reply here."]},{"i":"scripts","l":"./scripts/","p":["This folder will contain any executable scripts needed to run the package here, as well as any you develop that will be relevant to package use. Nodes/services will not be defined here, but if you, for example, use a shell script in a node or service, it would be placed here."]},{"i":"includepackage_name","l":"./include/package_name","p":["This directory is where all of your c++ header files will go if applicable."]},{"l":"Package Inspection","p":["ROS provides the rospack command-line tool in order to inspect packages:https://docs.ros.org/en/independent/api/rospkg/html/rospack.html"]},{"l":"Data Flow","p":["Data flow in ROS is described more technically here: ROS Concepts","In ROS, data flow is handled by a peer-to-peer network of individual pieces of software. These \"nodes\" are able to request and output data as you see fit. ROS handles this quite smartly, and loosely couples building blocks of software and data together to allow for software to be changed in a modular fashion."]},{"l":"Messages","p":["ROS Reference for Messages","Messages, and message types, are the primary abstraction used for data in the system. ROS provides wrappers for many primitive types to enable cohesion in the system.","Each message in ROS has a type, and ROS provides many types out of the box. These types can be easily googled, but a full list of primitive types supplied is found here:","http://docs.ros.org/en/noetic/api/std_msgs/html/index-msg.html","For example, the ROS type for a header, which provides data for the order of messages being sent and the sequence in which they are sent is represented as so:","Googling these types will only get you so far, as in ROS there is also the ability to define custom types. These types will not be documented anywhere besides in the codebase, and there is a command-line tool for accessing the specifications for each type: http://wiki.ros.org/rosmsg. Below are some basic commands that will be useful:"]},{"l":"Topics","p":["ROS Reference for Topics","Topics are a fundamental way ROS moves messages through the vehicle system. Topics are published and subscribed to by nodes, allowing nodes to exchange data with each other.","Topics have a very specific naming scheme in ROS:","All messages passed via nodes can be accessed through these topic names, and all data published in ROS will have an associate topic. Topics can be accessed by any other node in the system, as long as the nodes providing them are running.","To access topics, and see their content, a command-line tool called rostopic is utilized. Below are some basic commands using that tool: http://wiki.ros.org/rostopic"]},{"l":"Nodes","p":["ROS Reference for Nodes","A node in ROS is one of the fundamental building blocks of the software. A node serves as the basic computational unit in ROS, and the brunt of the work you do on the vehicle is node-based.","A node in ROS can both publish and subscribe to topics in the ROS system. Nodes can also provide services, which are discussed in the next section.","Publishing: Providing data to the ROS system Subscribing: Getting data from another node in the ROS system","Each node has a name in the system that is user defined, and these are part of what determine namespaces in ROS. A node handling raw camera input and output could be named /camera","In a ROS node, data is manipulated via the programming languages C++ and Python. Each node is responsible for a step in the process of data movement in the system. For example, to make the car detect objects, there http://wiki.ros.org/rosnode will be a detection pipeline needed starting from the camera and ending with whatever handles responding to detections. This pipeline would have multiple nodes, starting with /camera publishing to the topic /camera/image, and that would be picked up by the node /detector which would then publish its detections on /detector/detections. These detections would then be used by other nodes in the system as they see fit.","Similar to messages and topics, there is a command-line tool to inspect nodes: http://wiki.ros.org/rosnode. Some basic commands for inspecting nodes are found below:"]},{"l":"Services","p":["ROS Reference for Services","With publishing and subscribing, you have a data flow that provides data from many nodes in the system to many other nodes in the system, The caveat is that dataflow in this structure is largely one way.","ROS services provide a different way of implementing data flow in ROS, a request/reply based framework. This is very useful when building up quick computations and actions that do not need to be integrated in the larger system. For example, if you want a quick way to change settings on the vehicle, use a service! You can configure a service to change those settings, and then configure it to reply on a success.","ROS services are defined and displayed similar to messages. The key difference is that a message will have one single section of fields defining the datatypes shown in the message, whereas services have two. The first is the request body, and this defines all the data the service needs to handle the request. The second is the response body, which defines the data the service will provide upon completing the request. A service will look something like this (example pulled from http://wiki.ros.org/srv):","To see ROS services from a command-line interface, you can use two tool: rossrv, which functions very similarly to rosmsg, and rosservice, which is used to actively request services themselves and display services actively running in the system. Here are some examples for rossrv and rosservice:"]},{"l":"Parameters","p":["ROS Reference for Parameters","Parameters are how to set global constants in ROS. These are useful in many areas, such as configuration settings, numerical constants, and much more. You will use services for constants designed not to be changed often, as parameters are not used for high frequency dataflow.","As these are designed to be constants, the datatypes available for params are as follows:","32-bit integers","booleans","strings","doubles","iso8601 dates","lists","base64-encoded binary data","The command-line tool rosparam displays relevant information about parameters and their contents:"]},{"l":"Bags","p":["ROS Reference for Bags","In a robotics system, you may not have access to the robot whenever you need to develop something. Additionally, it is not practical to assume that you can spin up the vehicle to actively test what your software does in response to vehicle data. ROS provides a data storage solution called rosbags that solves this.","Specifically in our development environment, you have access to bags recorded at many times of the year with sensor data from the vehicle. These bags can be played, and when they are played, will spawn topics with data collected from that time. This will simulate what the car would actually output when it is running, and will allow you to rapidly test and develop.","Similar to all the other items above, there is a command-line tool for you to create and play these bags: http://wiki.ros.org/rosbag/Commandline"]}],[{"l":"Git Basics","p":["MSU SOAR uses git for version control. If you are not familiar with git, I’d recommend that you read the guides below to get background information:","What Is Version Control?","What Is Git?","We specifically use MSU’s gitlab service, and you can access the AVC group here: AVC GitLab"]},{"l":"Branches","p":["We will be using multiple git branches to coordinate development and isolate changes from each other. The main branch of the repository will be the branch dev. To get a local copy of the repository on your system, you will first execute the commands:","This will result the git repo being synced with the latest changes to our development branch. You will NOT be using this branch for your development purposes, however, and all changes to the dev branch will be made via pull requests.","When you are working on anything, whether it is a bugfix, feature, or testing code, you will create a new branch specifically for that purpose using the commands below."]},{"l":"Making Changes to a Branch","p":["Using Branches","When you are actively developing on the car, you will want to commit and push working code to the remote copy of the repo (the gitlab copy) in order to track the changes you’ve made."]},{"l":"git fetch","p":["The Fetch Command","The first command we will discuss is git fetch. Run this command around once a week to ensure that your local repository is tracking the remote repository"]},{"l":"git pull","p":["The Pull Command","This command will be run before you work every single time. This will ensure that your local branch is caught up with the remote repository, and is especially important if you are collaborating on a codebase change. You may have to resolve a merge conflict if you are working in the same areas of code, so consult the other author if need be."]},{"l":"git add","p":["The Add Command","This command is how you actually tell git that you want to track changes made to any files. You must do this in order to push code to the repo. You will add individual files and directories by yourself, and it is important to only add files that are relevant to the vehicles functionality and operation. For example, if you have developed other scripts to aid in your initial development progress, and they do not need to be run for your software to work in production, do not add those scripts."]},{"l":"git commit","p":["The Commit Command","This is how you actually save your changes to the branch. This will create a commit hash that saves that exact point in time, tracking all changes you’ve added to the branch. Additionally, unlike git add, git commit allows you to add a message detailing your changes concisely.","When you add and commit changes, please try to make your changes relatively minimal. Do not develop an entire new section of the codebase, then add files. Rather, you should add and commit in small steps, such as creating the file structure of your software, then adding and committing. This will allow you to easily rollback changes if you have made a mistake, and track where bugs were introduced more effectively."]},{"l":"git push","p":["The Push Command","Okay awesome! Now you’ve committed your changes to the local repo. You are able to track them and you can see a nice commit history detailing all the changes you’ve made. However, if you look at the gitlab, you will not see any of your changes there. This is because running git commit only commits changes locally. To have the remote repo track your changes, you need to use the git push command."]},{"l":"git stash","p":["The Stash Command","The final git command we will discuss is stashing changes. Stashing changes tells git to put them aside for later, which allows you to work on something else. Additionally, you may need to stash your changes if you have untracked work done on your branch and need to pull the latest changes from remote. You can then apply your stash and have your changes be merged with the most up to date version of your branch without having to mess with adding or committing."]},{"l":"Making a Merge Request","p":["The final git basic we will discuss is making merge requests. Merge requests are needed to ensure that multiple sets of eyes will see what changes you have made to the codebase, and serve as a barrier allowing team and program leads to ensure that the changes look good. Merge requests are to be done when a feature is complete, tested, and ready to be run on the vehicle, or when a bugfix has been completed. Below is a link specifying how to actually create a merge request using GitLab, and its recommended that you follow these steps to create one:","Creating Merge Requests"]}],[{"l":"Trello Basics","p":["For AVC development, we will be using Trello to track general development progress. We recommend you use and check Trello often, so that we minimize the amount of effort needed to check in on peoples progress.","Each subteam will have a trello board tracking general development items. For example, anything related to perception on the vehicle will be on the perception board, including bugfixes, optimizations, and new features/integrations. Any task that can completed will live on its respective teams trello board. To unify the boards among teams, the general schema for the boards is below."]},{"l":"Lists","p":["There will be 4 areas in each trello board:","Unassigned tasks","Assigned tasks","In-development","Developed tasks"]},{"l":"Unassigned Tasks","p":["These are tasks that are in the idea stage, and as a staging area for development items that do not have someone working on them currently. The goal is to use this list as an area to quickly mark down tasks during meetings, and to track development items before an issue is created.","Anyone in the team can and should put items into this section, but make sure they are broad enough to justify tracking its development over time."]},{"l":"Assigned Tasks","p":["These are tasks that are fully defined and fleshed out. This means that an issue has been created for them, and the respective team lead has defined exactly what needs to be accomplished in the issue description.","Before you move a task to assigned tasks, please do the following:","Create and fill out the issue","Make sure the issue has been assigned to a team member","Give the issue has an appropriate tag:","bug for bugfixes","feature for new development items","testing for testing and verification related development","organizational for team related tasks, such as meetings or forms","When you get assigned a card, or assign one to yourself, move it to the In-Development list!"]},{"l":"In-Development","p":["These tasks are tasks that are actively being worked on, or are going to be done in the near future. If you are planning on doing something in the current week, or have a task that is next for you personally, put it here."]},{"l":"Developed","p":["This section is for tasks that are finished. Thats kinda it."]},{"l":"Cards","p":["Cards are what makes up each list, and a card just generally defines a task. Anything you’ll do for SOAR that takes more than a minute will be a card. For example:","A feature such as developing a new ROS node","A bugfix such as fixing that ROS node","A test such as testing that you’ve actually fixed the bug you created","Cards can be created by everybody, but the team lead is responsible for cleaning up the cards and maintaining general order on the Trello board. Additionally, as mentioned above, team leads will assign people and tags to each card."]}],[{"l":"Tutorials","p":["Below are a bunch of online resources for further learning about the software we use on a daily basis."]},{"i":"unixlinux","l":"UNIX/Linux","p":["UNIX/Linux Tutorial for Beginners","This UNIX/Linux tutorial will cover all the basics of UNIX/Linux based operating systems, how to use command-line tools, and much much more. If you are not comfortable in a terminal environment or have not used Linux before, definitely check this tutorial out."]},{"l":"ROS","p":["ROS Tutorial Project","The ROS Tutorial Project was created to get our members familiar with the specifics of AVC's development environment. It's recommended that you start here, as it closely mimics the actual environment the club will have you develop in.","Official ROS Tutorial","The developers of ROS created their own tutorials for ROS, and they go into more detail regarding all the components ROS has to offer. You can use the docker image from the ROS Tutorial Project above, and skip the \"Installing and Configuring Your ROS Environment\" as the ROS Tutorial Project already covers that.","Clearpath Robotics Tutorial","A company called Clearpath robotics has created a tutorial to go along with a ground vehicle robot they developed, and in this tutorial you're able to simulate this robot. This requires the setup of a VM, but it provides a more visual way to interact with ROS"]},{"l":"Python","p":["Official Python Tutorial","The developers of python created this tutorial to comprehensively introduce you to Python. Be warned, it is very wordy not super interactive."]}],[{"l":"Getting Started","p":["If you haven't already, we'd recommend that you check out the ROS Tutorial Project. This is a tutorial that will allow you to run through all the development basics on a test repo. It also has some Linux tips that you will find useful if you are unfamiliar."]},{"l":"Cloning the Vehicle Repo","p":["The vehicle repo is where all of the vehicle software is stored. You can clone this directory anywhere, but I'd recommend that you create a separate directory, say soar/, in order to separate all your vehicle files. In this new directory, run:","And that's it for vehicle code."]},{"l":"Spinning up the Docker","p":["For development purposes, it is ideal to keep user environments uniform so that code works everywhere, not just on whatever system you happen to be on. For this, we use Docker, which is a container that standardizes our OS and dependencies across systems. When you run our Docker container, you are running a complete copy of the vehicle system, just without any sensors or vehicle hardware attached.","Our docker repository is where you will find the source. You should have a workable linux environment if you followed the ROS tutorial project, so spin that up. Firstly, cd into the same directory where you stored vehicle/ and clone the docker repo on commandline with:","Then cd into the docker/ directory and run:","This will build the docker image. Don't be alarmed if this takes a while, you are building an entire OS from scratch. To run the docker image, run:","And now your docker image is running!"]},{"l":"Building the Repository","p":["Finally, you can build the vehicle code. As our vehicle codebase is a mix of C++ and Python, it does need to be compiled and built before running. Run","For next steps, see Branching"]}],[{"l":"Branching"},{"l":"Overview","p":["Before you change anything in the vehicle codebase, it is important that you do one thing: branch. I'd recommend that you consult the Git Basics section of the wiki for a git tutorial/refresher if needed.","What branching ensures in our system is compartmentalization of changes across multiple developers. In our vehicle codebase, there is a lot going on, and multiple ROS nodes depend on multiple other nodes in order to function.","Say there is work required on a node called object_detection. Our work with object_avoidance may depend on the earlier version of object_detection. If object_detection is not fully functioning during its retooling, object_avoidance is not going to be developed further until that is done, and we can't have that.","In comes branches. Branches separate changes so that you can't break everyones code by yourself, only yours.","To manage all this, we will be using the Git Feature Branch Workflow."]},{"l":"In Practice","p":["Now theoretically, this concept works wonders. In practice, here is how this is executed:"]},{"i":"if-a-branch-hasnt-been-created","l":"If A Branch Hasn't Been Created","p":["Team leads and project leads will handle branch creation for most features, as they will be scoped and discussed prior to team member development. Feel free to create your own branch by following these instructions.","Create a new branch off of dev that describes your software. Should be prepended with \"feature-\" (i.e., \"feature-2d-sign-detector\"), and should be named in a similar fashion to the milestone for clarity. You can create a new branch by either:","On the main project page, next to where it displays the current branch in a dropdown, press the \"+\" icon, then select \"New branch.\" On the next page, make sure you select dev for \"create from\"","With a local checkout of the repository, first make sure you are on a recent version of the dev branch:","Then create a new branch:","Immediately create a merge request to merge this feature branch back into dev. Make sure to prepend \"WIP:\" to the issue title so that it's known that the software is not yet done"]},{"l":"For Active Developers","p":["Checkout Your Branch Run git checkout {feature-branch} on the branch associated with your milestone.","Develop software on your branch. Commit early and often (See Git Basics. Run automated testing pipelines if available.","Once software is ready to merge, remove WIP tag. Notify team lead that software is ready to merge (once automatic testing is enabled, must wait until automatic testing passes)."]}],[{"l":"Package Creation","p":["Make sure that you have read/followed the instructions for configuring your environment and creating a branch before creating a package. This will ensure that you're creating it in the right place!"]},{"l":"Command-line Creation","p":["First up is the creation of a package using command-line tools. You should begin by getting yourself into the correct directory under /vehicle/src/ corresponding to the purpose of your node. If you are developing a computer vision node using the cameras on the vehicle, you would want the command to be cd vehicle/src/perception/camera/. If you have any trouble figuring out the right spot, ask!","The next step is to actually create the package needed for use. The command for this is:","Make sure to remove the curly braces, they are just indicating that you need actual content there before running the command. {package_name} should be short, but descriptive. It also should be all lowercase, with _ as spaces. Package dependencies are just what libraries that your node will depend on, and here are a few examples:","roscpp and/or rospy for C++/Python nodes respectively. If you are not sure which language you are going to be using, feel free to include both as separate dependencies","std_msgs: A set of simple, standard message types.","sensor_msgs: A set of messages for common sensor types. If your node takes in raw sensor data, you will likely need this package","geometry_msgs: A set of messages containing geometric primitives. These are very commonly used by most packages, especially if they use transform data"]},{"l":"Package Contents","p":["ROS packages are more than just folders. Inside the package filesystem there are multiple different files needed to build, run, and keep track of everything going on in a ROS node. Both package.xml and CMakeLists.txt won't necessarily need editing unless you are adding ROS dependencies or developing with C++, but there are references below."]},{"i":"packagexml","l":"package.xml","p":["ROS Reference for package.xml","This is used to denote:","Description: What the package is used for","Maintainer: Who actually is developing for this package","License: Who can use this code These will be filled in with default values, and you should change them on initial package creation.","Additionally, this will also contain the dependencies that you listed when creating the package. If you need to add more later, you can use:","to easily add another dependency there."]},{"i":"cmakeliststxt","l":"CMakeLists.txt","p":["# add_compile_options(-std=c++11)","A few lines later, you'll notice another call to find_package():","Always make your node have a ${PROJECT_NAME}_ prefix to the output executable name! Otherwise, if you name your executable the same as one in another ROS package, it will fail to compile! You can remove the prefix using the set_target_properties() command below the add_executable() command.","Any non-ROS system libraries. Note that these will likely be CMake variables; for instance, LibPCL uses the ${PCL_INCLUDE_DIRS} as the include macro for this section. This isn't required for this tutorial project, but will likely be necessary for more complex projects.","Beyond the call to include_directories() there are several CMake commands that are used. The first, add_library(), is used when you want to compile a set of C++ code as a library and not as a full node, either for just your package or as a library that can be used outside your package. We aren't doing that here, so skip the add_library() command. Note the call to add_dependencies() right afterward; we will be calling this ourselves, but not at this point in the file.","First off, if you are going to be programming in C++, you will want to enable C++ 11 features. There is a line early on in the file that reads:","First off, there is a call to include_directories() that we will want to modify. There are two major things to add here:","If you use any non-ROS third party libraries for C++ code, you will add a call to find_package() for each of these packages here. The most common packages you might find here are OpenCV and LibPCL.","In the next block down, you will see a section titled\"Declare ROS messages, services and actions\". This section is used if your package provides any messages or services. If you are creating a custom message type in this package, specify that here.","Moving on to the add_dependencies() command, unless you have dependencies on system libraries (added with the find_package() command) or you compiled any libraries for your project, you can uncomment this line and leave it as-is.","Next, note the lines that read:","ROS Reference for CMakeLists.txt","The local include/ directory. By convention, C++ header files should go into the tutorial_pkg/include/ directory, with further subdirectories preferably added to aid organization. This directory is created by default, but you may notice here in the CMakeLists.txt file that it's been commented out. You should uncomment it here.","The next section, \"build\", is very important for C++ projects. If you are only programming in Python, you can skip this section.","The next three commands are what we'll be using when compiling our code. The add_executable() command allows you to set the output compiled node name(the first argument), and then takes in the path to all the source files you need to compile your node. You should uncomment this line, but depending on how you structure your source code you may need to come back and add the paths to your source files later.","This file is very important for the actual building of vehicle code. If you are using C++, editing this file will be necessary when developing. The following section is modified from the ROS Tutorial Project:","This is another location for ROS dependencies that you'll need to add on to if you add additional ROS dependencies later. Note that you need to edit both package.xml AND CMakeLists.txt or else your package will not compile after adding a dependency in one or the other, but not both.","Uncomment the line by removing the # symbol."]}],[{"l":"Node Creation","p":["Now that you've created a package, you're ready to get into actual development. The first step to actual development is creating a node, and to go through that process, we will use a template node to illustrate how we structure our ROS code."]},{"l":"First Steps","p":["The first thing you should do before using anything in this doc is actually creating a python file. You can do this on linux by executing","where [node_name] is the name of your node. Then you can copy the template and use it in your node's code."]},{"l":"Template Node"},{"l":"Code"},{"l":"Breakdown","p":["As you can see, a minimum functioning node does not require a ton of code, but we will still break it down into parts so your understanding is correct."]},{"l":"Shebang","p":["First up, we have the shebang. This tells your underlying Linux OS how to interpret this file. As you are creating a python node, this will always be#!/usr/bin/env python3."]},{"l":"Imports","p":["Next up is your imports. You can add any python packages present on the system here, but there are a few important ones that you shouldn't miss. If you recall your reading of Package Creation, you will remember that you declared some dependencies, such as std_msgs, rospy, and the likes. These will need to be imported here to be used in your python script, and likewise they will need to be included in your package dependencies. One important thing to note is that you should import message types as needed rather than doing import std_msgs.msg."]},{"l":"Class","p":["/published_topic","/subscribed_topic","A couple of notes:","Each publisher should only be published once, and you need to use distinct topic names for each publisher","Each subscriber must have their own callback (If you want a single callback with synced messages, use message_filters)","First up is the initialization function. In here, we define the inputs and outputs of your rosnode in terms of rostopics. For your subscriber, there's a minimum of three arguments:","MessageType","Now we get to the meat and bones of the operation, an object oriented ROS node. There are two ROS specific parts to pay attention to here: the publisher/subscriber initialization, and the callback function.","queue_size","self.callback","This determines how many messages will be queued before ros clears them from memory","This is the message type of the topic you want to publish. As covered in the imports section, you will import message types from a .msg import, and then they will go here.","This is the message type of the topic you want to subscribe to. As covered in the imports section, you will import message types from a .msg import, and then they will go here. If you are having trouble determining the message type of the topic you want, then run rostopic info /topic_name!","This is the topic name you want the node to publish data on. You choose this name yourself, so make it descriptive","This is the topic name you want the node to receive data from","This will be the callback function that is run everytime a new message is received. For your publisher, the arguments are:","To publish a message of ANY type, you need to fill out the fields of each message manually. Messages are just instances of a python class, and you will fill out each instance of a message like you would member variables of a python class. For example, a sensor_msgs/PointCloud2 is filled out like below ( these are not real values):","You can have multiple publishers and subscribers in one node, but there are some things you will have to watch out for:"]},{"l":"Main Function","p":["Lastly, we have the main function:","This code block spins up the node and ensures that it is executing properly. Some notable parts:","This line is the actual function call for main() in python.","This initializes the node with the name 'base_node'. Like every other name in this template, it should be changed. This one should change to match the functionality of the node.","This initializes the node, and subsequently initializes the publishers and subscribers, meaning that the node will begin to receive data.","This puts the node into a cycle of waiting for the next message and then executing."]}],[{"l":"Replaying Recorded Data","p":["During software development it is common to test software and algorithms on pre-recorded real-world and simulated data. ROS enables this ability through the use of .bag files. Each .bag contains the topics which were selected to be recorded at the time the file was created.","See the ROS Wiki article on the rosbag tool for more information on creating, playing, and inspecting .bag files."]},{"l":"ROS Dataset Locations","p":["The AVC team typically stores recorded datasets in on the NAS, which is mounted to most AVC servers and Docker environments under /mnt. External datasets (such as BDD100K, NuScenes, etc.) are mounted under /mnt/datasets-external while internal datasets, produced by the SOAR team, are available under /mnt/datasets and /mnt/dataset-dropbox."]},{"l":"Playing ROS Bag Data","p":["To play the ROS bag data, a system with ROS installed must be used. The most convenient way to do this for most will be through the use of the AVC vehicle docker. Once inside the docker, simply start roscore, then run:","This will play the rosbag, allowing the system to act as if it is ingesting real time data.","If a large number of bag files are included in the folder (i.e. bag_1.bag, bag_2.bag, ... bag_n.bag)and you would like to run over all of them, use:","Finally, to loop continuously, as is often desirable when testing, use the -l flag:"]},{"l":"Visualizing Using Rviz","p":["To visualize pre-recorded .bag data using Rviz, first set the directive to use simulated time (i.e. the time the data was recorded, and not the current time), otherwise Rviz will see the data is stale and ignore it.","First, start up rviz to graphically display data.","To properly display data, the transforms for the vehicle must be published. You can verify this by checking if the /tf_static topic is running by listing active topics using the command:","If the /tf_static topic is not published, then you can launch the transform manager with this command:","Once the /tf_static topic is published (through either of the methods above), the fixed frame may be selected. To do so, select the the drop-down in the upper left corner of the window under \"Displays > Global Options > Fixed Frame\" and select \"base_link\".","Next, below the \"Displays\" window should be a button which says \"Add\", select this, then select the \"By Topic\" tab – if the ROS bag is playing, topics should be listed in this tab. Lidar objects will be viewable as \"PointCloud2\" objects, and cameras as \"Images\" and so on.","One final note, with lidar objects, it is helpful to visualize these as \"Points\" as opposed to \"flat squares\" as is the default option. Not only are points easier to see, but they are also typically faster to render on weaker systems. Also consider setting Alpha to 1 on lower-end systems to reduce render times."]}],[{"l":"License","p":["MIT License","Copyright (c) 2023 MSU AVC","Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."]}]]